package ca.bc.gov.nrs.vdyp.backend.projection.model;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ca.bc.gov.nrs.vdyp.backend.api.v1.exceptions.PolygonValidationException;
import ca.bc.gov.nrs.vdyp.backend.model.v1.ValidationMessage;
import ca.bc.gov.nrs.vdyp.backend.model.v1.ValidationMessageKind;
import ca.bc.gov.nrs.vdyp.backend.projection.model.enumerations.ProjectionTypeCode;
import ca.bc.gov.nrs.vdyp.common_calculators.custom_exceptions.CommonCalculatorException;
import ca.bc.gov.nrs.vdyp.si32.site.SiteTool;

/** Identifies information regarding a single layer within a stand. */
public class Layer implements Comparable<Layer> {

	private static final Logger logger = LoggerFactory.getLogger(Layer.class);

	// BUSINESS KEY - all fields must have values */

	/** The layer's containing polygon */
	private Polygon polygon;

	/** The layer's layer id - from the LAYER_LEVEL_CODE, which must be distinct per polygon */
	private String layerId;

	// Optional members

	/**
	 * Holds the Layer within VDYP7 that this layer was processed as. If not processed within VDYP7, this member will
	 * contain an empty string.
	 * <p>
	 * Note that with layer summarization, multiple layers may be combined Integero a single layer for processing within
	 * VDYP7. This mechanism will help us to deaggregate that combined layer by informing us which particular layers
	 * make up the combined layer.
	 */
	private ProjectionTypeCode vdyp7LayerCode;

	/**
	 * This layer will be included in the projection iff this value is <code>true</code>. Typically it is false when it
	 * is a layer that has been combined Integero another layer.
	 */
	private Boolean doIncludeWithProjection;

	/**
	 * Indicates whether or not to suppress projected yields or not. Typically this is determined by the Non-Forest
	 * Descriptor at layer definition. However, this flag could allow for other mechanisms to control the suppression as
	 * well.
	 * <ul>
	 * <li><code>true</code>: All projected per hectare yields will be suppressed. All projected species percents will
	 * be returned as supplied at polygon definition.
	 * <li><code>false</code>: All projected per hectare yields and species percents are returned as they normally would
	 * be.
	 * </ul>
	 */
	private Boolean doSuppressPerHAYields;

	/** The rank code associated with the layer. Rank "1" indicates the primary layer. */
	private String rankCode;

	/**
	 * The non-forest descriptor associated with the layer. If one is not associated with the layer or one is not known,
	 * this value should be null.
	 */
	private String nonForestDescriptor;

	/** Crown Closure. If not known, should be set to null */
	private Short crownClosure;

	/** Basal Area. If not known, should be set to null */
	private Double basalArea;

	/** Basal Area. If not known, should be set to null */
	private Double treesPerHectare;

	/**
	 * The species associated with the Estimated Site Index value (if any). This value is generated by the SiteTool
	 * library from the actual species code. This value is null if no species is associated with estimatedSiteIndex. It
	 * is OK not to supply a Estimated SI Species in which case any supplied SI will eventually be associated with the
	 * leading species only.
	 */
	private String estimatedSiteIndexSpecies;

	/**
	 * The Estimated SI to be used in case the normal SI is not available. If not known, should be set to null.
	 */
	private Double estimatedSiteIndex;

	/** This value is (currently) always defined to be 7.5cm+. */
	private Double measuredUtilizationLevel;

	/**
	 * If <code>true<code>, the layer is marked as being a 'dead' layer with some component of the stand having been
	 * killed. If <code>false</code> it is a normal, living layer.
	 */
	private boolean isDeadLayer = false;

	/** The year in which the layer was killed. If the layer is not dead, the value null is used. */
	private Integer yearOfDeath;

	/** The age of the layer at time of death. If not dead, or the value isn't known, it is set to null. */
	private Double ageAtDeath;

	/** Percentage of layer that's stockable. If not known, it is set to null. */
	private Double percentStockable;

	/** The Sp0s (species groups; stands) of the layer, in the order they were supplied. */
	private List<Stand> sp0s;

	/** The species (sp64s) currently defined in the stand, sorted in the order they were supplied. */
	private List<Species> sp64s = new ArrayList<>();

	/**
	 * The list of SiteSpecies. These are the species groups, but with PA and PL groups combined, and with C and Y
	 * groups combined. This list is sorted by decreasing percentage.
	 */
	private List<SiteSpecies> siteSpecies;

	/** The type of projection this layer represents. */
	private ProjectionTypeCode assignedProjectionType;

	private LayerAdjustments adjustments;

	private LayerYields lastRequestedYield;

	private History history;

	private Layer() {
	}

	public String getLayerId() {
		return layerId;
	}

	public Polygon getPolygon() {
		return polygon;
	}

	public ProjectionTypeCode getVdyp7LayerCode() {
		return vdyp7LayerCode;
	}

	public Boolean doIncludeWithProjection() {
		return doIncludeWithProjection;
	}

	public String getRankCode() {
		return rankCode;
	}

	public String getNonForestDescriptor() {
		return nonForestDescriptor;
	}

	public Short getCrownClosure() {
		return crownClosure;
	}

	public Double getBasalArea() {
		return basalArea;
	}

	public Double getTreesPerHectare() {
		return treesPerHectare;
	}

	public String getEstimatedSiteIndexSpecies() {
		return estimatedSiteIndexSpecies;
	}

	public Double getEstimatedSiteIndex() {
		return estimatedSiteIndex;
	}

	public Double getMeasuredUtilizationLevel() {
		return measuredUtilizationLevel;
	}

	public boolean getIsDeadLayer() {
		return isDeadLayer;
	}

	public Integer getYearOfDeath() {
		return yearOfDeath;
	}

	public Double getAgeAtDeath() {
		return ageAtDeath;
	}

	public Double getPercentStockable() {
		return percentStockable;
	}

	public Map<String, Stand> getSp0sByNameMap() {
		var sp0sByName = new HashMap<String, Stand>();

		for (Stand s : sp0s) {
			sp0sByName.put(s.getSpeciesGroup().getSpeciesCode(), s);
		}

		return sp0sByName;
	}

	public List<Stand> getSp0sByName() {
		return sp0s.stream().sorted(new Comparator<Stand>() {

			@Override
			public int compare(Stand o1, Stand o2) {
				return o1.getSp0Code().compareTo(o2.getSp0Code());
			}
		}).toList();
	}

	public List<Stand> getSp0sAsSupplied() {
		return Collections.unmodifiableList(sp0s);
	}

	public List<Stand> getSp0sByPercent() {
		return sp0s.stream().sorted(new Comparator<Stand>() {

			@Override
			public int compare(Stand o1, Stand o2) {
				int result = signum(
						o2.getSpeciesGroup().getSpeciesPercent() - o1.getSpeciesGroup().getSpeciesPercent()
				);
				if (result == 0) {
					return o1.getStandIndex() - o2.getStandIndex();
				} else {
					return result;
				}
			}

			private int signum(double d) {
				return d > 0 ? 1 : d < 0 ? -1 : 0;
			}
		}).toList();
	}

	public List<Species> getSp64sAsSupplied() {
		return sp64s;
	}

	public List<Species> getSp64sByPercent() {
		return sp64s.stream().sorted(new Comparator<Species>() {

			@Override
			public int compare(Species o1, Species o2) {
				// Sort the sp64s by decreasing percentage. Those with equal percentage appear
				// in random order.
				return signum(o2.getSpeciesPercent() - o1.getSpeciesPercent());
			}

			private int signum(double d) {
				return d > 0 ? 1 : d < 0 ? -1 : 0;
			}
		}).toList();
	}

	public List<Species> getSp64sByName() {
		return sp64s.stream().sorted(new Comparator<Species>() {

			@Override
			public int compare(Species o1, Species o2) {
				return o1.getSpeciesCode().compareTo(o2.getSpeciesCode());
			}
		}).toList();
	}
	
	public List<SiteSpecies> getSiteSpecies() {
		return siteSpecies;
	}

	public ProjectionTypeCode getAssignedProjectionType() {
		return assignedProjectionType;
	}

	public LayerAdjustments getAdjustments() {
		return adjustments;
	}

	public LayerYields getLastRequestedYield() {
		return lastRequestedYield;
	}

	public Boolean getDoSuppressPerHAYields() {
		return doSuppressPerHAYields;
	}

	public History getHistory() {
		return history;
	}

	// MUTABLE data - these values may change during the lifetime of the entity.

	public void setDoIncludeWithProjection(Boolean doIncludeWithProjection) {
		this.doIncludeWithProjection = doIncludeWithProjection;
	}

	public void setVdyp7LayerCode(ProjectionTypeCode newVdyp7LayerCode) {
		this.vdyp7LayerCode = newVdyp7LayerCode;
	}

	public void setDoSuppressPerHAYields(boolean doSuppressPerHAYields) {
		this.doSuppressPerHAYields = doSuppressPerHAYields;
	}

	public void setAssignedProjectionType(ProjectionTypeCode newAssignedProjectionType) {
		this.assignedProjectionType = newAssignedProjectionType;
	}

	public static class Builder {
		private Layer layer = new Layer();

		public Builder layerId(String layerId) {
			layer.layerId = layerId;
			return this;
		}

		public Builder polygon(Polygon polygon) {
			layer.polygon = polygon;
			return this;
		}

		public Builder vdyp7LayerCode(ProjectionTypeCode vdyp7LayerCode) {
			layer.vdyp7LayerCode = vdyp7LayerCode;
			return this;
		}

		public Builder doIncludeWithProjection(Boolean doIncludeWithProjection) {
			layer.doIncludeWithProjection = doIncludeWithProjection;
			return this;
		}

		public Builder rankCode(String rankCode) {
			layer.rankCode = rankCode;
			return this;
		}

		public Builder nonForestDescriptor(String nonForestDescriptor) {
			layer.nonForestDescriptor = nonForestDescriptor;
			return this;
		}

		public Builder crownClosure(Short crownClosure) {
			layer.crownClosure = crownClosure;
			return this;
		}

		public Builder basalArea(Double basalArea) {
			layer.basalArea = basalArea;
			return this;
		}

		public Builder treesPerHectare(Double treesPerHectare) {
			layer.treesPerHectare = treesPerHectare;
			return this;
		}

		public Builder estimatedSiteIndexSpecies(String estimatedSiteIndexSpecies) {
			layer.estimatedSiteIndexSpecies = estimatedSiteIndexSpecies;
			return this;
		}

		public Builder estimatedSiteIndex(Double estimatedSiteIndex) {
			layer.estimatedSiteIndex = estimatedSiteIndex;
			return this;
		}

		public Builder measuredUtilizationLevel(Double measuredUtilizationLevel) {
			layer.measuredUtilizationLevel = measuredUtilizationLevel;
			return this;
		}

		public Builder isDeadLayer(boolean isDeadLayer) {
			layer.isDeadLayer = isDeadLayer;
			return this;
		}

		public Builder yearOfDeath(Integer yearOfDeath) {
			layer.yearOfDeath = yearOfDeath;
			return this;
		}

		public Builder ageAtDeath(Double ageAtDeath) {
			layer.ageAtDeath = ageAtDeath;
			return this;
		}

		public Builder precentStockable(Double percentStockable) {
			layer.percentStockable = percentStockable;
			return this;
		}

		public Builder species(List<Stand> sp0sAsSupplied) {
			layer.sp0s = sp0sAsSupplied;
			return this;
		}

		// sp64s is initialized to null on object creation. It is subsequently updated
		// when updateAfterSpeciesAdded is called. It is not possible to add any
		// meaningful values in the Builder because Species require the Layer to exist
		// in order to be created.

		public Builder assignedProjectionType(ProjectionTypeCode assignedProjectionType) {
			layer.assignedProjectionType = assignedProjectionType;
			return this;
		}

		public Builder adjustments(LayerAdjustments adjustments) {
			layer.adjustments = adjustments;
			return this;
		}

		public Builder lastRequestedYield(LayerYields lastRequestedYield) {
			layer.lastRequestedYield = lastRequestedYield;
			return this;
		}

		public Builder doSuppressPerHAYields(Boolean doSuppressPerHAYields) {
			layer.doSuppressPerHAYields = doSuppressPerHAYields;
			return this;
		}

		public Builder history(History history) {
			layer.history = history;
			return this;
		}

		public Layer build() {
			if (layer.layerId == null) {
				throw new IllegalStateException("Attempt to build a Layer with a null layerId");
			}

			return layer;
		}
	}

	/**
	 * A stand, has been added to a Stand of a Layer. Adjust the Layer state to reflect this.
	 * 
	 * @param stand the stand that was added
	 */
	public void addStand(Stand stand) {
		if (sp0s.contains(stand)) {
			throw new IllegalStateException(
					MessageFormat.format("Attempt to add a Stand {0} already in Layer {1}", stand, this)
			);
		}

		sp0s.add(stand);
	}

	public void updateAfterSp64Added(Species speciesInstance) {
		if (sp64s.contains(speciesInstance)) {
			throw new IllegalStateException(
					MessageFormat.format("Attempt to add a Species {0} already in Layer {1}", speciesInstance, this)
			);
		}

		sp64s.add(speciesInstance);
	}

	/**
	 * Return the <code>nthLeading</code> species group of the layer.
	 * 
	 * @param nthLeading the zero-based ordinal identifying the rank to be returned.
	 * @return as described. If <code>nthLeading</code> is not between 0 and the (number of species groups) - 1,
	 *         inclusive, <code>null</code> is returned.
	 */
	public Stand determineLeadingSp0(Integer nthLeading) {
		if (nthLeading < siteSpecies.size()) {
			return siteSpecies.get(nthLeading).getStand();
		} else {
			return null;
		}
	}

	/**
	 * Return the first Species of the <code>nthLeading</code> species group of the layer.
	 * 
	 * @param nthLeading the zero-based ordinal identifying the rank to be returned.
	 * @return as described. If <code>nthLeading</code> is not between 0 and the (number of species groups) - 1,
	 *         inclusive, or the identified species group has no species, <code>null</code> is returned.
	 */
	public Species determineLeadingSp64(Integer nthLeading) {

		Species species = null;

		if (nthLeading < siteSpecies.size()) {

			Stand stand = determineLeadingSp0(nthLeading);
			if (stand != null && stand.getSpecies().size() > 0) {
				species = stand.getSpecies().get(0);
			}
		}

		return species;
	}

	/**
	 * Return true iff this layer contains at least one sp64 with a height, and the leading sp64 of all sp0s is at least
	 * the given height.
	 * 
	 * @param minVeteranLayerHeight the height lower bound
	 * @return as described
	 */
	public Boolean doesHeightExceed(Double minHeight) {

		boolean heightRequirementMet = true;
		boolean haveSeenSp64WithHeight = false;

		for (Integer sp64Index = 0; sp64Index < sp64s.size(); sp64Index++) {

			var sp64 = findNthSpeciesByCriteria(sp64Index, SpeciesSelectionCriteria.AS_SUPPLIED);

			if (sp64.getDominantHeight() != null) {
				haveSeenSp64WithHeight = true;
				if (sp64.getDominantHeight() < minHeight) {
					heightRequirementMet = false;
					break;
				}
			}
		}

		return haveSeenSp64WithHeight && heightRequirementMet;
	}

	/**
	 * Return the <code>n</code>th species (Sp64) of the layer from a list sorted by <code>criteria</code>.
	 * 
	 * @param n        the zero-based index
	 * @param criteria the sorting criteria
	 * @return as described
	 */
	public Species findNthSpeciesByCriteria(Integer n, SpeciesSelectionCriteria criteria) {

		if (0 > n || n >= this.sp64s.size()) {
			throw new IllegalArgumentException(
					MessageFormat.format(
							"The parameter \"n\" (value {0}) must be between 0 and {1}, inclusive", n, this.sp64s.size()
					)
			);
		}

		switch (criteria) {
		case AS_SUPPLIED:
			return this.getSp64sAsSupplied().get(n);
		case BY_NAME:
			return this.getSp64sByName().get(n);
		case BY_PERCENT:
			return this.getSp64sByPercent().get(n);
		default:
			throw new IllegalArgumentException(
					MessageFormat.format("The parameter \"criteria\" (value {0}) is not a recognized value", criteria)
			);
		}
	}

	/**
	 * Return the assigned projection type for this layer; if one has not yet been assigned, determine it based on the
	 * containing polygon's characteristics.
	 * 
	 * @param polygon the layer's container
	 * @return as described
	 */
	public ProjectionTypeCode determineProjectionType(Polygon polygon) {

		var projectionType = this.getAssignedProjectionType();

		if (projectionType == ProjectionTypeCode.UNKNOWN) {
			if (this == polygon.getDeadLayer()) {
				projectionType = ProjectionTypeCode.DEAD;
			} else if (this == polygon.getPrimaryLayer() || this == polygon.getTargetedPrimaryLayer()) {
				projectionType = ProjectionTypeCode.PRIMARY;
			} else if (this == polygon.getVeteranLayer() || this == polygon.getTargetedVeteranLayer()) {
				projectionType = ProjectionTypeCode.VETERAN;
			} else if (this == polygon.getResidualLayer()) {
				projectionType = ProjectionTypeCode.RESIDUAL;
			} else if (this == polygon.getRegenerationLayer()) {
				projectionType = ProjectionTypeCode.REGENERATION;
			} else {
				projectionType = ProjectionTypeCode.DO_NOT_PROJECT;
			}
		}

		return projectionType;
	}

	/**
	 * lcl_DetermineLayerAgeAtYear - determine the layer's age at the given year,
	 * which must be non-null and between 1400 and 2500 (inclusive.)
	 * @param year as described
	 * @return as described
	 * @throws IllegalStateException if:
	 * <ul>
	 * <li>year is null or out of range
	 * <li><code>this</code> has no leading species
	 * <li>the leading species has no total age value
	 * <li>the containing polygon's measurement year cannot be calculated
	 * </ul>
	 */
	public double determineLayerAgeAtYear(Integer year) {
		if (year == null || year < Vdyp7Constants.MIN_CALENDAR_YEAR || year > Vdyp7Constants.MAX_CALENDAR_YEAR) {
			throw new IllegalArgumentException(MessageFormat.format("Invalid year {0}; must be non null and between {1} and {2} (inclusive)"
					, year, Vdyp7Constants.MIN_CALENDAR_YEAR, Vdyp7Constants.MAX_CALENDAR_YEAR));
		}
		
		Stand leadingSp0 = determineLeadingSp0(0);
		if (leadingSp0 == null) {
			throw new IllegalStateException(MessageFormat.format("Leading Sp0 not found for layer {0}", this));
		} else if (leadingSp0.getSpeciesGroup().getTotalAge() == null) {
			throw new IllegalStateException(MessageFormat.format("Leading Sp0 {0} of layer {1} has no total age", leadingSp0.getSpeciesGroup(), this));
		}
		
		Integer measurementYear = getPolygon().getMeasurementYear();
		if (measurementYear == null) {
			throw new IllegalStateException(MessageFormat.format("Measurement year is not known for polygon {0}", getPolygon()));
		}
		
		double layerAge = leadingSp0.getSpeciesGroup().getTotalAge() + year - measurementYear;
		
		if (layerAge < 0.0) {
			layerAge = 0.0;
		}
		
		return layerAge;
	}

	public void setAsDeadLayer(Integer yearOfDeath, Double percentStockKilled) {

		this.vdyp7LayerCode = ProjectionTypeCode.DEAD;
		this.isDeadLayer = true;
		this.percentStockable = percentStockKilled;
		this.yearOfDeath = yearOfDeath;

		logger.debug(
				"Layer {} marked as a Dead Layer with mortality occurring in {} and affecting {} of the land", this,
				yearOfDeath, percentStockable
		);
	}

	public void doCompleteDefinition(Polygon polygon) throws PolygonValidationException {

		if (getDoSuppressPerHAYields()) {
			setAssignedProjectionType(ProjectionTypeCode.UNKNOWN);
		}

		// Assign the projection type of the layer.

		if (getAssignedProjectionType() == ProjectionTypeCode.UNKNOWN) {

			var layerProjectionType = determineProjectionType(polygon);
			if (ProjectionTypeCode.ACTUAL_PROJECTION_TYPES_LIST.contains(layerProjectionType)) {
				setAssignedProjectionType(layerProjectionType);
				polygon.setLayerByProjectionType(layerProjectionType, this);
			} else if (layerProjectionType.equals(ProjectionTypeCode.UNKNOWN)) {
				// If the layer still does not have a projection type, suppress projection.
				setDoSuppressPerHAYields(true);
			} else if (layerProjectionType.equals(ProjectionTypeCode.DO_NOT_PROJECT)) {
				// If the layer is marked to not be projected, suppress projection.
				setDoSuppressPerHAYields(true);
			} else {
				throw new IllegalStateException(
						MessageFormat.format("Unrecognized ProjectionTypeCode {0}", layerProjectionType)
				);
			}
		}

		doBuildSiteSpecies();

		doCompleteSiteSpeciesSiteIndexInfo();

		// TODO: Continue work at V7Ext_CompletedPolygonDefinition line 4389
	}

	private void doBuildSiteSpecies() {

		var unsortedSiteSpecies = new ArrayList<SiteSpecies>();

		SiteSpecies pSiteSpecies = null;
		SiteSpecies cSiteSpecies = null;
		
		for (Stand stand : sp0s) {

			var standSp0 = stand.getSpeciesGroup();
			
			var newSiteSpecies = new SiteSpecies.Builder() //
					.hasBeenCombined(false) //
					.hasSiteInfo(standSp0.getSiteIndex() != null) //
					.stand(stand) //
					.totalSpeciesPercent(standSp0.getSpeciesPercent()) //
					.build();

			if ("C".equals(standSp0.getSpeciesCode()) || "Y".equals(standSp0.getSpeciesCode())) {

				if (cSiteSpecies == null) {

					cSiteSpecies = newSiteSpecies;
					unsortedSiteSpecies.add(newSiteSpecies);

				} else {
					var currentCedarSiteSpeciesGroup = cSiteSpecies.getStand().getSpeciesGroup();
					var percentageComparison = currentCedarSiteSpeciesGroup.getSpeciesPercent()
							- standSp0.getSpeciesPercent();
					var nameComparison = currentCedarSiteSpeciesGroup.getSpeciesCode()
							.compareTo(standSp0.getSpeciesCode());

					if (percentageComparison > 0 || percentageComparison == 0 && nameComparison < 0) {
						// The new cedar SiteSpecies will be merged into the existing one since it has
						// a lower percentage or the same percentage but a later name.
						cSiteSpecies.incrementTotalSpeciesPercent(newSiteSpecies.getTotalSpeciesPercent());
					} else {
						unsortedSiteSpecies.remove(cSiteSpecies);
						newSiteSpecies.incrementTotalSpeciesPercent(cSiteSpecies.getTotalSpeciesPercent());
						cSiteSpecies = newSiteSpecies;
						unsortedSiteSpecies.add(newSiteSpecies);
					}
				}
			} else if ("PA".equals(standSp0.getSpeciesCode()) || "PL".equals(standSp0.getSpeciesCode())) {

				if (pSiteSpecies == null) {

					pSiteSpecies = newSiteSpecies;
					unsortedSiteSpecies.add(newSiteSpecies);

				} else {
					var currentPineSiteSpeciesGroup = pSiteSpecies.getStand().getSpeciesGroup();
					var percentageComparison = currentPineSiteSpeciesGroup.getSpeciesPercent()
							- standSp0.getSpeciesPercent();
					var nameComparison = currentPineSiteSpeciesGroup.getSpeciesCode()
							.compareTo(standSp0.getSpeciesCode());

					if (percentageComparison > 0 || percentageComparison == 0 && nameComparison < 0) {
						// The new pine SiteSpecies will be merged into the existing one since it has
						// a lower percentage or the same percentage but a later name.
						pSiteSpecies.incrementTotalSpeciesPercent(newSiteSpecies.getTotalSpeciesPercent());
					} else {
						unsortedSiteSpecies.remove(pSiteSpecies);
						newSiteSpecies.incrementTotalSpeciesPercent(pSiteSpecies.getTotalSpeciesPercent());
						pSiteSpecies = newSiteSpecies;
						unsortedSiteSpecies.add(newSiteSpecies);
					}
				}
			} else {
				unsortedSiteSpecies.add(newSiteSpecies);
			}
		}

		siteSpecies = unsortedSiteSpecies;
		siteSpecies.sort(SiteSpecies::compareTo);
	}

	/**
	 * Fills in the Site Species SI Info for this layer.
	 * <p>
	 * This routine implements the algorithm described in IPSCB205 for 'Site Species Fill In'. Boiled down into
	 * pseudo-code, the following rules are implemented:
	 * <ol>
	 * <li>The supplied layer must have data and have a stand description.
	 * <li>Determine leading site species. If site species already has site information, we are done.
	 * <li>Determine a 'donor' species by selecting the first alphabetical species in the stand description which has
	 * site information.
	 * <li>Copy donor species age to site species age.
	 * <li>Convert SI of donor species to that of site species and copy to Estimated Site Index field.
	 * <li>Compute height for site species based on Age and SI. In our case, we will reset height as it will be
	 * recomputed when all species details are filled in later.
	 * </ol>
	 * 
	 * @throws PolygonValidationException
	 */
	private void doCompleteSiteSpeciesSiteIndexInfo() throws PolygonValidationException {

		boolean amDone = false;

		if (this.sp64s.size() == 0) {
			amDone = true;
			logger.debug("Layer \"{}\" does not have a stand description. Cannot complete site index info.", this);
		}

		Stand stand = null;
		Species siteSpecies = null;
		Species speciesGroup = null;

		if (!amDone) {
			stand = determineLeadingSp0(0 /* first */);
			siteSpecies = determineLeadingSp64(0 /* first */);

			if (stand != null) {
				logger.debug(
						"Located Site SP0 \"{}\" with site info: Age: {}, Ht: {}, SI: {}",
						stand.getSpeciesGroup().getSpeciesCode(), stand.getSpeciesGroup().getTotalAge(),
						stand.getSpeciesGroup().getDominantHeight(), stand.getSpeciesGroup().getSiteIndex()
				);
			}
			if (siteSpecies != null) {
				logger.debug(
						"Located Site SP64 \"{}\" with site info: Age: {}, Ht: {}, SI: {}",
						siteSpecies.getSpeciesCode(), siteSpecies.getTotalAge(), siteSpecies.getDominantHeight(),
						siteSpecies.getSiteIndex()
				);
			}

			if (stand == null || siteSpecies == null) {
				logger.error("Leading site species could not be determined; cannot continue");

				throw new PolygonValidationException(
						new ValidationMessage(ValidationMessageKind.NO_LEADING_SPECIES, polygon, getLayerId())
				);
			}

			speciesGroup = stand.getSpeciesGroup();

			if (siteSpecies.getTotalAge() != null && siteSpecies.getDominantHeight() != null
					&& siteSpecies.getSiteIndex() != null) {

				logger.debug("Leading site species {} already has site information", siteSpecies);
				amDone = true;

			} else {

				siteSpecies.calculateUndefinedFieldValues();
				speciesGroup.setSiteCurve(siteSpecies.getSiteCurve());
			}
		}

		Species donorSpecies = null;

		if (!amDone) {

			var sp64sByName = getSp64sByName();

			for (var candidateDonorSpecies : sp64sByName) {

				if (candidateDonorSpecies.getTotalAge() != null && candidateDonorSpecies.getDominantHeight() != null
						&& !siteSpecies.getSpeciesCode().equals(candidateDonorSpecies.getSpeciesCode())) {

					if (candidateDonorSpecies.getSiteIndex() == null) {
						candidateDonorSpecies.calculateUndefinedFieldValues();
					}

					donorSpecies = candidateDonorSpecies;

					if (donorSpecies != null) {
						logger.debug(
								"Located Donor SP64 \"{}\" with site info: Age: {}, Ht: {}, SI: {}",
								donorSpecies.getSpeciesCode(), donorSpecies.getTotalAge(),
								donorSpecies.getDominantHeight(), donorSpecies.getSiteIndex()
						);
					}
				}
			}

			if (donorSpecies == null) {
				amDone = true;
				logger.debug("Layer {}: unable to find donor species", this);
			}
		}

		if (siteSpecies != null && donorSpecies != null) {

			if (!amDone) {

				// Copy donor species age to the site species.

				siteSpecies.setTotalAge(donorSpecies.getTotalAge());

				logger.debug(
						"Set site species {} age from donor species {} to {}", siteSpecies.getSpeciesCode(),
						donorSpecies.getSpeciesCode(), donorSpecies.getTotalAge()
				);

				// Attempt to convert and copy (or, failing that, just copy) site index to site species

				try {
					double siteIndex = SiteTool.convertSiteIndexBetweenCurves(
							donorSpecies.getSiteCurve(), donorSpecies.getSiteIndex(), siteSpecies.getSiteCurve()
					);

					speciesGroup.setSiteIndex(siteIndex);
					siteSpecies.setSiteIndex(siteIndex);

					logger.debug(
							"Donor {} site index {} converted to {} and assigned to site species {}",
							donorSpecies.getSpeciesCode(), donorSpecies.getSiteIndex(), siteSpecies.getSiteIndex(),
							siteSpecies.getSpeciesCode()
					);

				} catch (CommonCalculatorException e) {

					double siteIndex = donorSpecies.getSiteIndex();

					speciesGroup.setSiteIndex(siteIndex);
					siteSpecies.setSiteIndex(siteIndex);

					logger.debug(
							"No conversion of site index from {} to {}. Assigned straight copy of donor site index value {} to site species",
							donorSpecies.getSpeciesCode(), siteSpecies.getSpeciesCode(), donorSpecies.getSiteIndex()
					);
				}

				// Now reset dominant height and recompute it from the values assigned above.

				siteSpecies.resetDominantHeight();
				siteSpecies.calculateUndefinedFieldValues();

				amDone = true;
			}

			if (amDone && stand != null && siteSpecies != null) {
				speciesGroup.updateAfterSp64Added(siteSpecies);
				speciesGroup.calculateUndefinedFieldValues();
			}
		}
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof Layer that) {
			return compareTo(that) == 0;
		} else {
			return false;
		}
	}

	@Override
	public int hashCode() {
		return polygon.hashCode() * 17 + this.layerId.hashCode();
	}

	@Override
	public int compareTo(Layer that) {
		if (this.polygon.compareTo(that.polygon) == 0) {
			return this.layerId.compareTo(that.layerId);
		} else {
			return 0;
		}
	}

	// toString implementations

	@Override
	public String toString() {
		return polygon.toString() + ":" + this.getLayerId();
	}

	public String toDetailedString() {
		// TODO: elaborate, in the manner of V7Ext_LogLayerDescriptor
		return toString();
	}
}
