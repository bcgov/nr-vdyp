package ca.bc.gov.nrs.vdyp.backend.projection.model;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import ca.bc.gov.nrs.vdyp.backend.projection.model.enumerations.ProjectionTypeCode;

/** Identifies information regarding a single layer within a stand. */
public class Layer implements Comparable<Layer> {
	
	// BUSINESS KEY - all fields must have values */
	
	/** The layer's containing polygon */
	private Polygon polygon;

	/** The layer's layer id - from the LAYER_LEVEL_CODE, which must be distinct per polygon */
	private String layerId;

	// Optional members 
	
	/**
	 * Holds the Layer within VDYP7 that this layer was processed as. If not processed within VDYP7, this member will
	 * contain an empty string.
	 * <p>
	 * Note that with layer summarization, multiple layers may be combined Integero a single layer for processing within
	 * VDYP7. This mechanism will help us to deaggregate that combined layer by informing us which particular layers
	 * make up the combined layer.
	 */
	private ProjectionTypeCode vdyp7LayerCode;

	/**
	 * This layer will be included in the projection iff this value is <code>true</code>. Typically it is false when it
	 * is a layer that has been combined Integero another layer.
	 */
	private Boolean doIncludeWithProjection;

	/**
	 * Indicates whether or not to suppress projected yields or not. Typically this is determined by the Non-Forest
	 * Descriptor at layer definition. However, this flag could allow for other mechanisms to control the suppression as
	 * well.
	 * <ul>
	 * <li><code>true</code>: All projected per hectare yields will be suppressed. All projected species percents will
	 * be returned as supplied at polygon definition.
	 * <li><code>false</code>: All projected per hectare yields and species percents are returned as they normally would
	 * be.
	 * </ul>
	 */
	private Boolean doSuppressPerHAYields;

	/** The rank code associated with the layer. Rank "1" indicates the primary layer. */
	private String rankCode;

	/**
	 * The non-forest descriptor associated with the layer. If one is not associated with the layer or one is not known,
	 * this value should be null.
	 */
	private String nonForestDescriptor;

	/** Crown Closure. If not known, should be set to -9.0 */
	private Short crownClosure;

	/** Basal Area. If not known, should be set to -9.0 */
	private Double basalArea;

	/** Basal Area. If not known, should be set to -9.0 */
	private Double treesPerHectare;

	/**
	 * The species associated with the Estimated Site Index value (if any). This value is generated by the SiteTool
	 * library from the actual species code. This value is null if no species is associated with estimatedSiteIndex. It
	 * is OK not to supply a Estimated SI Species in which case any supplied SI will eventually be associated with the
	 * leading species only.
	 */
	private String estimatedSiteIndexSpecies;

	/**
	 * The Estimated SI to be used in case the normal SI is not available. If not known, should be set to -9.0.
	 */
	private Double estimatedSiteIndex;

	/** This value is (currently) always defined to be 7.5cm+. */
	private Double measuredUtilizationLevel;

	/**
	 * If <code>true<code>, the layer is marked as being a 'dead' layer with some component of the stand having been
	 * killed. If <code>false</code> it is a normal, living layer.
	 */
	private Boolean isDeadLayer;

	/** The year in which the layer was killed. If the layer is not dead, the value -9 is used. */
	private Integer yearOfDeath;

	/** The age of the layer at time of death. If not dead, or the value isn't known, it is set to -9.0. */
	private Double ageAtDeath;

	/** Percentage of layer that's stockable. If not known, it is set to -9.0. */
	private Double precentStockable;

	/** The pp0s (species groups; stands) of the layer, in the order they were supplied. */
	private List<Stand> sp0s;

	/** The species (sp64s) currently defined in the stand, sorted in the order they were supplied. */
	private List<Species> sp64s = new ArrayList<>();

	/** The type of projection this layer represents. */
	private ProjectionTypeCode assignedProjectionType;

	private SiteSpeciesSorting siteSpeciesOrdering;

	private LayerAdjustments adjustments;

	private LayerYields lastRequestedYield;

	private History history;

	private Layer() {
	}

	public String getLayerId() {
		return layerId;
	}

	public Polygon getPolygon() {
		return polygon;
	}

	public ProjectionTypeCode getVDYP7LayerCode() {
		return vdyp7LayerCode;
	}

	public Boolean doIncludeWithProjection() {
		return doIncludeWithProjection;
	}

	public Boolean isDoSuppressPerHAYields() {
		return doSuppressPerHAYields;
	}

	public String getRankCode() {
		return rankCode;
	}

	public String getNonForestDescriptor() {
		return nonForestDescriptor;
	}

	public Short getCrownClosure() {
		return crownClosure;
	}

	public Double getBasalArea() {
		return basalArea;
	}

	public Double getTreesPerHectare() {
		return treesPerHectare;
	}

	public String getEstimatedSiteIndexSpecies() {
		return estimatedSiteIndexSpecies;
	}

	public Double getEstimatedSiteIndex() {
		return estimatedSiteIndex;
	}

	public Double getMeasuredUtilizationLevel() {
		return measuredUtilizationLevel;
	}

	public Boolean isDeadLayer() {
		return isDeadLayer;
	}

	public Integer getYearOfDeath() {
		return yearOfDeath;
	}

	public Double getAgeAtDeath() {
		return ageAtDeath;
	}

	public Double getPercentStockable() {
		return precentStockable;
	}

	public Map<String, Stand> getSp0sByName() {
		var sp0sByName = new HashMap<String, Stand>();

		for (Stand s : sp0s) {
			sp0sByName.put(s.getSpeciesGroup().getSpeciesCode(), s);
		}

		return sp0sByName;
	}

	public List<Stand> getSp0sAsSupplied() {
		return sp0s;
	}

	public List<Stand> getSp0sByPercent() {
		return sp0s.stream().sorted(new Comparator<Stand>() {

			@Override
			public int compare(Stand o1, Stand o2) {
				return signum(o1.getSpeciesGroup().getSpeciesPercent() - o2.getSpeciesGroup().getSpeciesPercent());
			}

			private int signum(double d) {
				return d > 0 ? 1 : d < 0 ? -1 : 0;
			}
		}).toList();
	}

	public List<Species> getSp64sAsSupplied() {
		return sp64s;
	}

	public List<Species> getSp64sByPercent() {
		return sp64s.stream().sorted(new Comparator<Species>() {

			@Override
			public int compare(Species o1, Species o2) {
				return signum(o1.getSpeciesPercent() - o2.getSpeciesPercent());
			}

			private int signum(double d) {
				return d > 0 ? 1 : d < 0 ? -1 : 0;
			}
		}).toList();
	}

	public List<Species> getSp64sByName() {
		return sp64s.stream().sorted(new Comparator<Species>() {

			@Override
			public int compare(Species o1, Species o2) {
				return o1.getSpeciesCode().compareTo(o2.getSpeciesCode());
			}
		}).toList();
	}

	public ProjectionTypeCode getAssignedProjectionType() {
		return assignedProjectionType;
	}

	public SiteSpeciesSorting getSiteSpeciesOrdering() {
		return siteSpeciesOrdering;
	}

	public LayerAdjustments getAdjustments() {
		return adjustments;
	}

	public LayerYields getLastRequestedYield() {
		return lastRequestedYield;
	}

	public Boolean doSuppressPerHAYields() {
		return doSuppressPerHAYields;
	}

	public History getHistory() {
		return history;
	}

	// MUTABLE data - these values may change during the lifetime of the entity.

	public void setDoIncludeWithProjection(Boolean doIncludeWithProjection) {
		this.doIncludeWithProjection = doIncludeWithProjection;
	}

	public void setVDYP7LayerCode(ProjectionTypeCode newVdyp7LayerCode) {
		this.vdyp7LayerCode = newVdyp7LayerCode;
	}

	public void setDoSuppressPerHAYields(boolean doSuppressPerHAYields) {
		this.doSuppressPerHAYields = doSuppressPerHAYields;
	}

	public static class Builder {
		private Layer layer = new Layer();

		public Builder layerId(String layerId) {
			layer.layerId = layerId;
			return this;
		}

		public Builder polygon(Polygon polygon) {
			layer.polygon = polygon;
			return this;
		}

		public Builder vdyp7LayerCode(ProjectionTypeCode sVDYP7LayerCode) {
			layer.vdyp7LayerCode = sVDYP7LayerCode;
			return this;
		}

		public Builder doIncludeWithProjection(Boolean doIncludeWithProjection) {
			layer.doIncludeWithProjection = doIncludeWithProjection;
			return this;
		}

		public Builder rankCode(String rankCode) {
			layer.rankCode = rankCode;
			return this;
		}

		public Builder nonForestDescriptor(String nonForestDescriptor) {
			layer.nonForestDescriptor = nonForestDescriptor;
			return this;
		}

		public Builder crownClosure(Short crownClosure) {
			layer.crownClosure = crownClosure;
			return this;
		}

		public Builder basalArea(Double basalArea) {
			layer.basalArea = basalArea;
			return this;
		}

		public Builder treesPerHectare(Double treesPerHectare) {
			layer.treesPerHectare = treesPerHectare;
			return this;
		}

		public Builder estimatedSiteIndexSpecies(String estimatedSiteIndexSpecies) {
			layer.estimatedSiteIndexSpecies = estimatedSiteIndexSpecies;
			return this;
		}

		public Builder estimatedSiteIndex(Double estimatedSiteIndex) {
			layer.estimatedSiteIndex = estimatedSiteIndex;
			return this;
		}

		public Builder measuredUtilizationLevel(Double measuredUtilizationLevel) {
			layer.measuredUtilizationLevel = measuredUtilizationLevel;
			return this;
		}

		public Builder isDeadLayer(Boolean isDeadLayer) {
			layer.isDeadLayer = isDeadLayer;
			return this;
		}

		public Builder yearOfDeath(Integer yearOfDeath) {
			layer.yearOfDeath = yearOfDeath;
			return this;
		}

		public Builder ageAtDeath(Double ageAtDeath) {
			layer.ageAtDeath = ageAtDeath;
			return this;
		}

		public Builder precentStockable(Double precentStockable) {
			layer.precentStockable = precentStockable;
			return this;
		}

		public Builder species(List<Stand> sp0sAsSupplied) {
			layer.sp0s = sp0sAsSupplied;
			return this;
		}

		// sp64s is initialized to null on object creation. It is subsequently updated
		// when updateAfterSpeciesAdded is called. It is not possible to add any 
		// meaningful values in the Builder because Species require the Layer to exist
		// in order to be created.

		public Builder assignedProjectionType(ProjectionTypeCode assignedProjectionType) {
			layer.assignedProjectionType = assignedProjectionType;
			return this;
		}

		public Builder siteSpeciesOrdering(SiteSpeciesSorting siteSpeciesOrdering) {
			layer.siteSpeciesOrdering = siteSpeciesOrdering;
			return this;
		}

		public Builder adjustments(LayerAdjustments adjustments) {
			layer.adjustments = adjustments;
			return this;
		}

		public Builder lastRequestedYield(LayerYields lastRequestedYield) {
			layer.lastRequestedYield = lastRequestedYield;
			return this;
		}

		public Builder doSuppressPerHAYields(Boolean doSuppressPerHAYields) {
			layer.doSuppressPerHAYields = doSuppressPerHAYields;
			return this;
		}

		public Builder history(History history) {
			layer.history = history;
			return this;
		}

		public Layer build() {
			if (layer.layerId == null) {
				throw new IllegalStateException("Attempt to build a Layer with a null layerId");
			}
			
			return layer;
		}
	}

	/**
	 * Return the <code>nthLeading</code> species group of the layer.
	 * 
	 * @param nthLeading the zero-based ordinal identifying the rank to be returned.
	 * @return as described. If <code>nthLeading</code> is not between 0 and the (number of species groups) - 1,
	 *         inclusive, <code>null</code> is returned.
	 */
	public Stand determineLeadingSp0(Integer nthLeading) {
		if (nthLeading < siteSpeciesOrdering.getSiteSpeciesArray().size()) {
			return siteSpeciesOrdering.getSiteSpeciesArray().get(nthLeading).getSpeciesGroupComponent();
		} else {
			return null;
		}
	}

	/**
	 * Return the first Species of the <code>nthLeading</code> species group of the layer.
	 * 
	 * @param nthLeading the zero-based ordinal identifying the rank to be returned.
	 * @return as described. If <code>nthLeading</code> is not between 0 and the (number of species groups) - 1,
	 *         inclusive, or the identified species group has no species, <code>null</code> is returned.
	 */
	public Species determineLeadingSp64(Integer nthLeading) {

		Species species = null;

		if (nthLeading < siteSpeciesOrdering.getSiteSpeciesArray().size()) {

			Stand stand = determineLeadingSp0(nthLeading);
			if (stand != null && stand.getSpecies().size() > 0) {
				species = stand.getSpecies().get(0);
			}
		}

		return species;
	}

	/**
	 * Return true iff this layer contains at least one sp64 with a height, and the leading sp64 of all sp0s is at least
	 * the given height.
	 * 
	 * @param minVeteranLayerHeight the height lower bound
	 * @return as described
	 */
	public Boolean doesHeightExceed(Double minHeight) {

		boolean heightRequirementMet = true;
		boolean haveSeenSp64WithHeight = false;

		for (Integer sp64Index = 0; sp64Index < sp64s.size(); sp64Index++) {

			var sp64 = findNthSpeciesByCriteria(sp64Index, SpeciesSelectionCriteria.AS_SUPPLIED);

			if (sp64.getDominantHeight() != null) {
				haveSeenSp64WithHeight = true;
				if (sp64.getDominantHeight() < minHeight) {
					heightRequirementMet = false;
					break;
				}
			}
		}

		return haveSeenSp64WithHeight && heightRequirementMet;
	}

	/**
	 * Return the <code>n</code>th species (Sp64) of the layer from a list sorted by <code>criteria</code>.
	 * 
	 * @param n        the zero-based index
	 * @param criteria the sorting criteria
	 * @return as described
	 */
	public Species findNthSpeciesByCriteria(Integer n, SpeciesSelectionCriteria criteria) {

		if (0 > n || n >= this.sp64s.size()) {
			throw new IllegalArgumentException(
					MessageFormat.format(
							"The parameter \"n\" (value {0}) must be between 0 and {1}, inclusive", n, this.sp64s.size()
					)
			);
		}

		switch (criteria) {
		case AS_SUPPLIED:
			return this.getSp64sAsSupplied().get(n);
		case BY_NAME:
			return this.getSp64sByName().get(n);
		case BY_PERCENT:
			return this.getSp64sByPercent().get(n);
		default:
			throw new IllegalArgumentException(
					MessageFormat.format("The parameter \"criteria\" (value {0}) is not a recognized value", criteria)
			);
		}
	}

	/**
	 * Return the assigned projection type for this layer; if one has not yet been assigned, determine it based on the
	 * containing polygon's characteristics.
	 * 
	 * @param polygon the layer's container
	 * @return as described
	 */
	public ProjectionTypeCode determineProjectionType(Polygon polygon) {

		var projectionType = this.getAssignedProjectionType();

		if (projectionType == ProjectionTypeCode.UNKNOWN) {
			if (this == polygon.getDeadLayer()) {
				projectionType = ProjectionTypeCode.DEAD;
			} else if (this == polygon.getPrimaryLayer() || this == polygon.getTargetedPrimaryLayer()) {
				projectionType = ProjectionTypeCode.PRIMARY;
			} else if (this == polygon.getVeteranLayer() || this == polygon.getTargetedVeteranLayer()) {
				projectionType = ProjectionTypeCode.VETERAN;
			} else if (this == polygon.getResidualLayer()) {
				projectionType = ProjectionTypeCode.RESIDUAL;
			} else if (this == polygon.getRegenerationLayer()) {
				projectionType = ProjectionTypeCode.REGENERATION;
			} else {
				projectionType = ProjectionTypeCode.DO_NOT_PROJECT;
			}
		}

		return projectionType;
	}

	/** 
	 * A species, and possibly a stand, has been added to a Stand of a Layer. Adjust the
	 * Layer state to reflect this.
	 * 
	 * @param stand the stand that was added
	 * @param species the species that was added
	 */
	public void updateAfterSpeciesAdded(Stand stand, Species species) {
		if (! sp0s.contains(stand)) {
			sp0s.add(stand);
		}
		
		// Record the species structures into the each of the required
		// arrays. The sorting of the appropriate arrays will occur
		// when needed.
		//
		// If the species is a duplicate, since we do want to maintain a 
		// count of the number of species supplied into the layer, including 
		// duplicates we added the species to sp64 whether it is a duplicate
		// or not.
		
		sp64s.add(species);
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof Layer that) {
			return compareTo(that) == 0;
		} else {
			return false;
		}
	}
	
	@Override
	public int hashCode() {
		return polygon.hashCode() * 17 + this.layerId.hashCode();
	}
	
	@Override
	public int compareTo(Layer that) {
		if (this.polygon.compareTo(that.polygon) == 0) {
			return this.layerId.compareTo(that.layerId);
		} else {
			return 0;
		}
	}
	
	// toString implementations

	@Override
	public String toString() {
		return polygon.toString() + ":" + this.getLayerId();
	}

	public String toDetailedString() {
		// TODO: elaborate, in the manner of V7Ext_LogLayerDescriptor
		return toString();
	}
}
