package ca.bc.gov.nrs.vdyp.backend.projection.model;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.event.Level;

import ca.bc.gov.nrs.vdyp.backend.api.v1.exceptions.PolygonValidationException;
import ca.bc.gov.nrs.vdyp.backend.model.v1.MessageSeverityCode;
import ca.bc.gov.nrs.vdyp.backend.model.v1.ValidationMessage;
import ca.bc.gov.nrs.vdyp.backend.model.v1.ValidationMessageKind;
import ca.bc.gov.nrs.vdyp.backend.projection.ProjectionContext;
import ca.bc.gov.nrs.vdyp.backend.projection.model.enumerations.GrowthModelCode;
import ca.bc.gov.nrs.vdyp.backend.projection.model.enumerations.ProcessingModeCode;
import ca.bc.gov.nrs.vdyp.backend.projection.model.enumerations.ProjectionTypeCode;
import ca.bc.gov.nrs.vdyp.backend.projection.model.enumerations.ReturnCode;
import ca.bc.gov.nrs.vdyp.backend.utils.Utils;
import ca.bc.gov.nrs.vdyp.common.Reference;
import ca.bc.gov.nrs.vdyp.common_calculators.custom_exceptions.CommonCalculatorException;
import ca.bc.gov.nrs.vdyp.common_calculators.enumerations.SiteIndexEquation;
import ca.bc.gov.nrs.vdyp.si32.site.SiteTool;

/** Identifies information regarding a single layer within a stand. */
public class Layer implements Comparable<Layer> {

	private static final Logger logger = LoggerFactory.getLogger(Layer.class);

	// BUSINESS KEY - all fields must have values */

	/** The layer's containing polygon */
	private Polygon polygon;

	/** The layer's layer id - from the LAYER_LEVEL_CODE, which must be distinct per polygon */
	private String layerId;

	// Optional members

	/**
	 * Holds the Layer within VDYP7 that this layer was processed as. If not processed within VDYP7, this member will
	 * contain an empty string.
	 * <p>
	 * Note that with layer summarization, multiple layers may be combined Integero a single layer for processing within
	 * VDYP7. This mechanism will help us to deaggregate that combined layer by informing us which particular layers
	 * make up the combined layer.
	 */
	private ProjectionTypeCode vdyp7LayerCode;

	/**
	 * This layer will be included in the projection iff this value is <code>true</code>. Typically it is false when it
	 * is a layer that has been combined Integero another layer.
	 */
	private Boolean doIncludeWithProjection;

	/**
	 * Indicates whether or not to suppress projected yields or not. Typically this is determined by the Non-Forest
	 * Descriptor at layer definition. However, this flag could allow for other mechanisms to control the suppression as
	 * well.
	 * <ul>
	 * <li><code>true</code>: All projected per hectare yields will be suppressed. All projected species percents will
	 * be returned as supplied at polygon definition.
	 * <li><code>false</code>: All projected per hectare yields and species percents are returned as they normally would
	 * be.
	 * </ul>
	 */
	private Boolean doSuppressPerHAYields;

	/** The rank code associated with the layer. Rank "1" indicates the primary layer. */
	private String rankCode;

	/**
	 * The non-forest descriptor associated with the layer. If one is not associated with the layer or one is not known,
	 * this value should be null.
	 */
	private String nonForestDescriptor;

	/** Crown Closure. If not known, should be set to null */
	private Short crownClosure;

	/** Basal Area. If not known, should be set to null */
	private Double basalArea;

	/** Basal Area. If not known, should be set to null */
	private Double treesPerHectare;

	/**
	 * The species associated with the Estimated Site Index value (if any). This value is generated by the SiteTool
	 * library from the actual species code. This value is null if no species is associated with estimatedSiteIndex. It
	 * is OK not to supply a Estimated SI Species in which case any supplied SI will eventually be associated with the
	 * leading species only.
	 */
	private String estimatedSiteIndexSpecies;

	/**
	 * The Estimated SI to be used in case the normal SI is not available. If not known, should be set to null.
	 */
	private Double estimatedSiteIndex;

	/** This value is (currently) always defined to be 7.5cm+. */
	private Double measuredUtilizationLevel;

	/**
	 * If <code>true<code>, the layer is marked as being a 'dead' layer with some component of the stand having been
	 * killed. If <code>false</code> it is a normal, living layer.
	 */
	private boolean isDeadLayer = false;

	/** The year in which the layer was killed. If the layer is not dead, the value null is used. */
	private Integer yearOfDeath;

	/** The age of the layer at time of death. If not dead, or the value isn't known, it is set to null. */
	private Double ageAtDeath;

	/** Percentage of layer that's stockable. If not known, it is set to null. */
	private Double percentStockable;

	/** The Sp0s (species groups; stands) of the layer, in the order they were supplied. */
	private List<Stand> sp0s = new ArrayList<>();

	/** The species (sp64s) currently defined in the stand, sorted in the order they were supplied. */
	private List<Species> sp64s = new ArrayList<>();

	/**
	 * The list of SiteSpecies. These are the species groups, but with PA and PL groups combined, and with C and Y
	 * groups combined. This list is sorted by decreasing percentage.
	 */
	private List<SiteSpecies> siteSpecies;

	/**
	 * The list is used between the time the SiteSpecies and built and when they are sorted. Once sorted, this
	 * list is null'd.
	 */
	private List<SiteSpecies> unsortedSiteSpecies;
	
	/** The type of projection this layer represents. */
	private ProjectionTypeCode assignedProjectionType;

	private LayerAdjustments adjustments;

	private History history;

	private Layer() {
	}

	public String getLayerId() {
		return layerId;
	}

	public Polygon getPolygon() {
		return polygon;
	}

	public ProjectionTypeCode getVdyp7LayerCode() {
		return vdyp7LayerCode;
	}

	public Boolean doIncludeWithProjection() {
		return doIncludeWithProjection;
	}

	public String getRankCode() {
		return rankCode;
	}

	public String getNonForestDescriptor() {
		return nonForestDescriptor;
	}

	public Short getCrownClosure() {
		return crownClosure;
	}

	public Double getBasalArea() {
		return basalArea;
	}

	public Double getTreesPerHectare() {
		return treesPerHectare;
	}

	public String getEstimatedSiteIndexSpecies() {
		return estimatedSiteIndexSpecies;
	}

	public Double getEstimatedSiteIndex() {
		return estimatedSiteIndex;
	}

	public Double getMeasuredUtilizationLevel() {
		return measuredUtilizationLevel;
	}

	public boolean getIsDeadLayer() {
		return isDeadLayer;
	}

	public Integer getYearOfDeath() {
		return yearOfDeath;
	}

	public Double getAgeAtDeath() {
		return ageAtDeath;
	}

	public Double getPercentStockable() {
		return percentStockable;
	}

	public Map<String, Stand> getSp0sByNameMap() {
		var sp0sByName = new HashMap<String, Stand>();

		for (Stand s : sp0s) {
			sp0sByName.put(s.getSpeciesGroup().getSpeciesCode(), s);
		}

		return sp0sByName;
	}

	public List<Stand> getSp0sByName() {
		return sp0s.stream().sorted(new Stand.ByIncreasingNameComparator()).toList();
	}

	public List<Stand> getSp0sAsSupplied() {
		return Collections.unmodifiableList(sp0s);
	}

	public List<Stand> getSp0sByPercent() {
		return sp0s.stream().sorted(new Stand.ByDecreasingPercentageComparator()).toList();
	}

	public List<Species> getSp64sAsSupplied() {
		return sp64s;
	}

	public List<Species> getSp64sByPercent() {
		return sp64s.stream().sorted(new Species.ByDecreasingPercentageComparator()).toList();
	}

	public List<Species> getSp64sByName() {
		return sp64s.stream().sorted(new Species.ByIncreasingNameComparator()).toList();
	}

	public List<SiteSpecies> getSiteSpecies() {
		return siteSpecies;
	}

	public ProjectionTypeCode getAssignedProjectionType() {
		return assignedProjectionType;
	}

	public LayerAdjustments getAdjustments() {
		return adjustments;
	}

	public Boolean getDoSuppressPerHAYields() {
		return doSuppressPerHAYields;
	}

	public History getHistory() {
		return history;
	}

	// MUTABLE data - these values may change during the lifetime of the entity.

	public void setDoIncludeWithProjection(Boolean doIncludeWithProjection) {
		polygon.ensureUnlocked();
		this.doIncludeWithProjection = doIncludeWithProjection;
	}

	public void setVdyp7LayerCode(ProjectionTypeCode newVdyp7LayerCode) {
		polygon.ensureUnlocked();
		this.vdyp7LayerCode = newVdyp7LayerCode;
	}

	public void setDoSuppressPerHAYields(boolean doSuppressPerHAYields) {
		polygon.ensureUnlocked();
		this.doSuppressPerHAYields = doSuppressPerHAYields;
	}

	public void setAssignedProjectionType(ProjectionTypeCode newAssignedProjectionType) {
		polygon.ensureUnlocked();
		this.assignedProjectionType = newAssignedProjectionType;
		polygon.setLayerByProjectionType(this.assignedProjectionType, this);
	}

	public static class Builder {
		private Layer layer = new Layer();

		public Builder layerId(String layerId) {
			layer.layerId = layerId;
			return this;
		}

		public Builder polygon(Polygon polygon) {
			layer.polygon = polygon;
			return this;
		}

		public Builder vdyp7LayerCode(ProjectionTypeCode vdyp7LayerCode) {
			layer.vdyp7LayerCode = vdyp7LayerCode;
			return this;
		}

		public Builder doIncludeWithProjection(Boolean doIncludeWithProjection) {
			layer.doIncludeWithProjection = doIncludeWithProjection;
			return this;
		}

		public Builder rankCode(String rankCode) {
			layer.rankCode = rankCode;
			return this;
		}

		public Builder nonForestDescriptor(String nonForestDescriptor) {
			layer.nonForestDescriptor = nonForestDescriptor;
			return this;
		}

		public Builder crownClosure(Short crownClosure) {
			layer.crownClosure = crownClosure;
			return this;
		}

		public Builder basalArea(Double basalArea) {
			layer.basalArea = basalArea;
			return this;
		}

		public Builder treesPerHectare(Double treesPerHectare) {
			layer.treesPerHectare = treesPerHectare;
			return this;
		}

		public Builder estimatedSiteIndexSpecies(String estimatedSiteIndexSpecies) {
			layer.estimatedSiteIndexSpecies = estimatedSiteIndexSpecies;
			return this;
		}

		public Builder estimatedSiteIndex(Double estimatedSiteIndex) {
			layer.estimatedSiteIndex = estimatedSiteIndex;
			return this;
		}

		public Builder measuredUtilizationLevel(Double measuredUtilizationLevel) {
			layer.measuredUtilizationLevel = measuredUtilizationLevel;
			return this;
		}

		public Builder isDeadLayer(boolean isDeadLayer) {
			layer.isDeadLayer = isDeadLayer;
			return this;
		}

		public Builder yearOfDeath(Integer yearOfDeath) {
			layer.yearOfDeath = yearOfDeath;
			return this;
		}

		public Builder ageAtDeath(Double ageAtDeath) {
			layer.ageAtDeath = ageAtDeath;
			return this;
		}

		public Builder precentStockable(Double percentStockable) {
			layer.percentStockable = percentStockable;
			return this;
		}

		// sp64s is initialized to null on object creation. It is subsequently updated
		// when updateAfterSpeciesAdded is called. It is not possible to add any
		// meaningful values in the Builder because Species require the Layer to exist
		// in order to be created.

		public Builder assignedProjectionType(ProjectionTypeCode assignedProjectionType) {
			layer.assignedProjectionType = assignedProjectionType;
			return this;
		}

		public Builder adjustments(LayerAdjustments adjustments) {
			layer.adjustments = adjustments;
			return this;
		}

		public Builder doSuppressPerHAYields(Boolean doSuppressPerHAYields) {
			layer.doSuppressPerHAYields = doSuppressPerHAYields;
			return this;
		}

		public Builder history(History history) {
			layer.history = history;
			return this;
		}

		public Layer build() {
			if (layer.layerId == null) {
				throw new IllegalStateException("Attempt to build a Layer with a null layerId");
			}

			return layer;
		}
	}

	/**
	 * A stand, has been added to a Stand of a Layer. Adjust the Layer state to reflect this.
	 *
	 * @param stand the stand that was added
	 */
	public void addStand(Stand stand) {
		if (sp0s.contains(stand)) {
			throw new IllegalStateException(
					MessageFormat.format("Attempt to add a Stand {0} already in Layer {1}", stand, this)
			);
		}

		sp0s.add(stand);
	}

	public void addSp64(Species speciesInstance) {
		if (sp64s.contains(speciesInstance)) {
			throw new IllegalStateException(
					MessageFormat.format("Attempt to add a Species {0} already in Layer {1}", speciesInstance, this)
			);
		}

		sp64s.add(speciesInstance);
	}

	/**
	 * V7Int_ApplyEstimatedSI
	 *
	 * Routine implementing the logic of assigning an Estimated Site Index to a species.
	 * <p>
	 * The rules are defined in the document IPSCB205.doc. Summary of these rules, filling in some unstated assumptions:
	 * <ul>
	 * <li>All polygons, regardless of inventory type: apply the business logic for VRISTART
	 * <li>Fill in the species details:
	 * <ol>
	 * <li>For each species in the stand:
	 * <ol>
	 * <li>Fill in the SI details for the species.
	 * <li>If the corresponding SP0 has no site information and the current species contains site information, assign
	 * the site information to the SP0.
	 * <li>Next species
	 * </ol>
	 * <li>If the resulting SI causes us to change Initial Growth Models, then we need to reapply the Estimated SI and
	 * resort the species.
	 * </ol>
	 * Notes:
	 * <p>
	 * 2003/12/16: According to Cam's 2003/12/15 e-mail, we will copy over height and age and site curve number to the
	 * SP0 so that they will appear with the species information in the VRISTART/FIPSTART input files.
	 * <p>
	 * 2004/02/19: According to Cam's 2004/02/12 e-mail describing application of a computed height based on the site
	 * index when a species has site information and is less than 30 years of age.
	 * <p>
	 * 2004/11/28: Added a step 5 to the PART C logic as the application of the estimated site species may cause a
	 * change in the initial model to be used. For instance, this will happen if the Estimated SI causes a FIP Inventory
	 * polygon to flip one way or the other around 10.0 m.
	 * <p>
	 * 2009/07/08: Produce an informational message that input height was reset due to an Estimated SI assignment.
	 * <p>
	 *
	 * @param currentGrowthModel      the Growth Model that is currently being used
	 * @param doPreventRecursiveCalls The definition of this routine allows for a recursive call back to this routine to
	 *                                fill in the blanks in case we change Initial Processing modes as a result of
	 *                                applying an Estimated SI. If this is not desired, then set this parameter to TRUE.
	 *                                Normally, this parameter is FALSE to allow recursive calls.
	 *
	 * @throws PolygonValidationException
	 */
	public void calculateEstimatedSiteIndex(
			ProjectionContext context, GrowthModelCode currentGrowthModel, boolean doPreventRecursiveCalls
	) throws PolygonValidationException {

		// If we have the site species and the total age is less than
		// 30 years of age, use the estimated site index as the actual
		// site index to use.

		applyEstimatedSiteIndex_VriStart(context);

		logger.debug("{}: adding site index information to any species that need it", this);

		for (var speciesGroup : getSp0sByPercent()) {

			for (var sp64 : speciesGroup.getSpeciesByPercent()) {
				boolean doRecomputeInputHeight = false;

				logger.debug(
						"species {}: percent {}; age: {}; height: {}; site index: {}", sp64.getSpeciesCode(),
						sp64.getSpeciesPercent(), sp64.getTotalAge(), sp64.getDominantHeight(), sp64.getSiteIndex()
				);

				if (sp64.getTotalAge() != null && sp64.getTotalAge() < 30 && sp64.getSiteIndex() != null) {

					sp64.resetDominantHeight();
					doRecomputeInputHeight = true;

					logger.debug("{}: species {}: height recalculation required", this, sp64);

				} else if (sp64.getTotalAge() != null && sp64.getTotalAge() < 30 && sp64.getDominantHeight() > 0
						&& sp64.getSiteIndex() == null) {

					sp64.setSiteIndex(sp64.determineSiteIndexFromDominantHeightAndAge());

					polygon.addDefinitionMessage(
							new PolygonMessage.Builder().returnCode(ReturnCode.SUCCESS).stand(speciesGroup)
									.severity(MessageSeverityCode.WARNING)
									.message(
											new ValidationMessage(
													ValidationMessageKind.ESTIMATED_SI_UNAVAILABLE,
													sp64.getSpeciesCode(), sp64.getTotalAge()
											)
									).build()
					);

					logger.warn(
							"{}: species {}: Site index triplet still not completed. Using final fallback of computing site index from age and height ({} = f({}, {}))",
							this, sp64, sp64.getSiteIndex(), sp64.getTotalAge(), sp64.getDominantHeight()
					);
				}

				sp64.calculateUndefinedFieldValues();

				if (doRecomputeInputHeight) {

					polygon.addDefinitionMessage(
							new PolygonMessage.Builder() //
									.returnCode(ReturnCode.SUCCESS) //
									.stand(speciesGroup) //
									.severity(MessageSeverityCode.INFORMATION) //
									.message(
											new ValidationMessage(
													ValidationMessageKind.REASSIGNED_HEIGHT, this, sp64,
													sp64.getSiteIndex(), sp64.getTotalAge(), sp64.getDominantHeight()
											)
									).build()
					);

					logger.info(
							"{}: species {}: based on estimated site index of {}, recomputed input height at age {} to be {}",
							this, sp64, sp64.getSiteIndex(), sp64.getTotalAge(), sp64.getDominantHeight()
					);
				}

				// Copy site index information from this species to the species group

				var sp0 = speciesGroup.getSpeciesGroup();

				if (sp0.getSiteIndex() == null && sp64.getSiteIndex() != null) {
					sp0.setAgeAtBreastHeight(sp64.getAgeAtBreastHeight());
					sp0.setDominantHeight(sp64.getDominantHeight());
					sp0.setSiteIndex(sp64.getSiteIndex());
					sp0.setTotalAge(sp64.getTotalAge());
					sp0.setSiteCurve(sp64.getSiteCurve());
				}

				if (sp0.getTotalAge() == null || sp0.getDominantHeight() == null) {
					sp0.setTotalAge(sp64.getTotalAge());
					sp0.setDominantHeight(sp64.getDominantHeight());
				}

				if (sp0.getSiteCurve() == null) {
					sp0.setSiteCurve(sp64.getSiteCurve());
				}
			}
		}

		var rGrowthModel = new Reference<GrowthModelCode>();
		var rProcessingModel = new Reference<ProcessingModeCode>();
		var rPrimaryLayer = new Reference<Layer>();

		polygon.calculateInitialProcessingModel(rGrowthModel, rProcessingModel, rPrimaryLayer);

		GrowthModelCode newGrowthModel = rGrowthModel.get();
		if (newGrowthModel != currentGrowthModel && !doPreventRecursiveCalls) {

			logger.debug("{}: switching to growth model {}", this, newGrowthModel);

			calculateEstimatedSiteIndex(context, newGrowthModel, true /* do not recurse */);
		}
	}

	/**
	 * <b>lcl_ApplyEstimatedSI_VRISTART</b>
	 * <p>
	 * Apply the logic of applying the Estimated Site Index to the layer for a VRISTART polygon.
	 * <p>
	 * Remarks
	 * <p>
	 * The logic to be applied is defined in IPSCB204. The logic has been turned around a bit to make it more efficient.
	 * <ol>
	 * <li>If an EST_SI was supplied:
	 * <li>Record EST_SI and EST_SI Species as the SI of interest.
	 * <li>Otherwise
	 * <li>Scan the stand for the first species with an age/height pair and the age >= 30.0
	 * <li>If such as species was found
	 * <li>Fill in the species details to determine the SI.
	 * <li>Record computed SI and Species as the SI of interest.
	 * <li>Scan for any species with an age < 30.0
	 * <li>If such a species was found
	 * <li>If an SI Species is available and a SINDEX SI Conversion exists
	 * <li>Assign the converted SI to the target species.
	 * <li>Otherwise
	 * <li>Apply the Estimated SI to the species directly.
	 * </ol>
	 * Modifications to the above:
	 * <p>
	 * <ul>
	 * <li>Added a check to see that if older species were encountered and we still apply an Est SI to a younger
	 * species. If we do, then we will want to generate note to that effect.
	 * <li>When assigning Estimated SI, ensure YTBH is also reset so that it will be recomputed for the new SI.
	 * <li>Added some additional logic to support supplying SI information to a leading species which has no SI
	 * information. Up to now, the only information supplied was SI. However, it is possible that age could be missing
	 * as well. If that is the case, total age is supplied from the first supplied species which has an age assigned to
	 * it.
	 * <li>Produce an informational message when assigning Estimated SI to a species. See Sam's related e-mail from this
	 * date.
	 * </ul>
	 *
	 * @param context the projection context of this projection
	 */
	private void applyEstimatedSiteIndex_VriStart(ProjectionContext context) {

		logger.debug("{}: determining estimated site index from age 30+ species", this);

		String estimatedSiteIndexSpeciesCode = getEstimatedSiteIndexSpecies();
		Double estimatedSiteIndex = getEstimatedSiteIndex();

		SiteIndexEquation estimatedCurve = null;
		Double estimatedAge = null;

		if (getEstimatedSiteIndex() != null) {

			estimatedCurve = SiteTool.getSICurve(getEstimatedSiteIndexSpecies(), getPolygon().isCoastal());
			for (Species s : getSp64sAsSupplied()) {
				estimatedAge = s.getTotalAge();
				if (estimatedAge != null) {
					break;
				}
			}
		} else {
			for (Species s : getSp64sByPercent()) {

				if (Utils.safeGet(s.getTotalAge()) >= 30.0 && s.getDominantHeight() != null) {

					s.calculateUndefinedFieldValues();

					estimatedSiteIndex = s.getSiteIndex();
					estimatedSiteIndexSpeciesCode = s.getSpeciesCode();
					estimatedAge = s.getTotalAge();
					if (s.getSiteCurve() != null) {
						estimatedCurve = s.getSiteCurve();
					} else {
						estimatedCurve = SiteTool.getSICurve(getEstimatedSiteIndexSpecies(), getPolygon().isCoastal());
					}

					logger.debug(
							"{}: estimated site index will come from species {} with age: {} and height: {}", this,
							s.getSpeciesCode(), s.getTotalAge(), s.getDominantHeight()
					);

					break;

				} else {
					logger.debug(
							"{}: species {} with age: {} and height: {} is not a candidate for supplying estimated site index",
							this, s.getSpeciesCode(), s.getTotalAge(), s.getDominantHeight()
					);
				}
			}

			logger.debug(
					"{}: estimated site index {} from species {} (age {}; curve: {})", this, estimatedSiteIndex,
					estimatedSiteIndexSpeciesCode, estimatedAge, estimatedCurve
			);
		}

		if (estimatedSiteIndex != null) {

			var leadingSpecies = determineLeadingSp64(0);

			logger.debug(
					"{}: scanning for young tree species. Leading sp64 is {}", this,
					leadingSpecies == null ? "<none>" : leadingSpecies.getSpeciesCode()
			);

			for (Species s : getSp64sByPercent()) {
				logger.debug("{}: checking species {}", this, s.getSpeciesCode());

				Double targetSiteIndex = null;

				if (s.getTotalAge() != null && s.getTotalAge() < 30
						|| s.compareTo(leadingSpecies) == 0 && leadingSpecies.getTotalAge() == null) {

					var targetCurve = s.getSiteCurve();

					logger.debug(
							"species {} {} requires an estimated site index", s,
							s.getTotalAge() != null ? "with age " + s.getTotalAge() : "with an unknown age"
					);

					if (estimatedSiteIndex != null && targetCurve == null) {
						targetCurve = SiteTool.getSICurve(s.getSpeciesCode(), polygon.isCoastal());
						logger.debug("site index curve not supplied, using default {}", targetCurve.name());
					}

					if (estimatedCurve != null && targetCurve != null && estimatedCurve != targetCurve) {
						try {
							targetSiteIndex = SiteTool
									.convertSiteIndexBetweenCurves(estimatedCurve, estimatedSiteIndex, targetCurve);
						} catch (CommonCalculatorException e) {
							logger.debug(
									"failed to convert site index curve {} to {}; error: {}", estimatedCurve,
									targetCurve, e.getMessage()
							);
							targetSiteIndex = null;
						}
					}

					if (targetSiteIndex == null) {
						s.setSiteIndex(estimatedSiteIndex);
						s.setYearsToBreastHeight(null);

						polygon.addDefinitionMessage(
								new PolygonMessage.Builder() //
										.returnCode(ReturnCode.SUCCESS) //
										.stand(s.getStand()) //
										.severity(MessageSeverityCode.INFORMATION) //
										.message(
												new ValidationMessage(
														ValidationMessageKind.ASSIGNING_ESTIMATED_SITE_INDEX,
														estimatedSiteIndex, s.getSpeciesCode()
												)
										).build()
						);

						logger.info(
								"assigning to current species {} directly from estimated site index the value of {}",
								s.getSpeciesCode(), estimatedSiteIndex
						);
					} else {
						s.setSiteIndex(targetSiteIndex);
						s.setYearsToBreastHeight(null);

						polygon.addDefinitionMessage(
								new PolygonMessage.Builder() //
										.returnCode(ReturnCode.SUCCESS) //
										.stand(s.getStand()) //
										.severity(MessageSeverityCode.INFORMATION) //
										.message(
												new ValidationMessage(
														ValidationMessageKind.ASSIGNING_ESTIMATED_SITE_INDEX,
														estimatedSiteIndex, s.getSpeciesCode()
												)
										).build()
						);

						logger.info(
								"assigning to current species {} a converted site index the value of {}",
								s.getSpeciesCode(), targetSiteIndex
						);
					}

					if (s.getTotalAge() == null) {
						s.setTotalAge(estimatedAge);

						logger.debug(
								"assigning to current species {} a total age value of {}", s.getSpeciesCode(),
								estimatedAge
						);
					}

					if (estimatedSiteIndex != null && estimatedAge != null) {
						polygon.addDefinitionMessage(
								new PolygonMessage.Builder() //
										.returnCode(ReturnCode.SUCCESS) //
										.layer(this) //
										.severity(MessageSeverityCode.INFORMATION) //
										.message(
												new ValidationMessage(
														ValidationMessageKind.ESTIMATE_APPLIED_FROM_OTHER_SPECIES,
														estimatedSiteIndexSpeciesCode, s.getSpeciesCode()
												)
										).build()
						);
					}
				} else {
					logger.info(
							"{}: species {} with age {} does not require an estimated site index", this,
							s.getSpeciesCode(), s.getTotalAge()
					);
				}
			}
		}
	}

	public void estimateCrownClosure(ProjectionContext context) {

		if (crownClosure == null) {

			if (this == polygon.getLayerByProjectionType(ProjectionTypeCode.UNKNOWN)) {
				// this is the primary layer

				Species leadingSp64 = this.determineLeadingSp64(0);
				if (leadingSp64 != null && leadingSp64.getDominantHeight() >= 10.0) {
					var estimatedCrownClosure = SiteTool
							.getSpeciesDefaultCrownClosure(leadingSp64.getSpeciesCode(), polygon.isCoastal());
					logger.debug("{}: estimating crown closure of primary layer at {}", this, estimatedCrownClosure);
					crownClosure = (short) estimatedCrownClosure;
				} else if (leadingSp64 == null) {
					polygon.disableProjectionsOfType(assignedProjectionType);
					context.addMessage(
							Level.WARN,
							"{0}: Crown closure was not supplied and there is no leading sp64 from which it can be determined. Disabling projection",
							this
					);
					logger.debug("Disabling projections of type {}", assignedProjectionType);
				}
			} else if (this == polygon.getLayerByProjectionType(ProjectionTypeCode.VETERAN)) {
				// this is the veteran layer

				short estimatedCrownClosure = 4;
				logger.debug("{}: estimating crown closure of veteran layer at {}", this, estimatedCrownClosure);
				crownClosure = estimatedCrownClosure;
			} else {
				// do nothing - no need to estimate crown closure for non-primary, non-veteran layer
			}
		}
	}

	/**
	 * <b>V7Int_DetermineLeadingSp0</b>
	 * <p>
	 * Return the <code>nthLeading</code> species group of the layer.
	 * <p>
	 * <b>Remarks</b>
	 * <ul>
	 * <li>"nth leading" is defined as the SP0 with the highest contributing percent and sorted by decreasing order of
	 * percent.
	 * <li>As the layer of leading SP0s is maintained in leading species order, the nth leading SP0 is simply the nth
	 * element in the array of SP0s.
	 * <li>If we are returning the nth species group alphabetically. A scan must be made of species in the stand in
	 * alphabetical order until the requested species is located.
	 * </ul>
	 * 
	 * @param nthLeading the zero-based ordinal identifying the rank to be returned. If there are fewer species in the
	 *                   layer than this number, <code>null</code> is returned.
	 * @return as described
	 */
	public Stand determineLeadingSp0(Integer nthLeading) {
		
		Stand stand = null;
		
		if (siteSpecies != null) {
			if (nthLeading < siteSpecies.size()) {
				stand = siteSpecies.get(nthLeading).getStand();
			}
		} else if (unsortedSiteSpecies != null) {
			
			var leadingSp0 = unsortedSiteSpecies.stream().max(new Comparator<SiteSpecies>() {

				@Override
				public int compare(SiteSpecies o1, SiteSpecies o2) {
					return (int)(o1.getTotalSpeciesPercent() - o2.getTotalSpeciesPercent());
				}});
			
			if (leadingSp0.isPresent()) {
				stand = leadingSp0.get().getStand();
			}
		}
		
		return stand;
	}

	/**
	 * Return the first Species of the <code>nthLeading</code> species group of the layer.
	 *
	 * @param nthLeading the zero-based ordinal identifying the rank to be returned.
	 * @return as described. If <code>nthLeading</code> is not between 0 and the (number of species groups) - 1,
	 *         inclusive, or the identified species group has no species, <code>null</code> is returned.
	 */
	public Species determineLeadingSp64(Integer nthLeading) {

		Species species = null;

		if (nthLeading < unsortedSiteSpecies.size()) {

			Stand stand = determineLeadingSp0(nthLeading);
			if (stand != null && stand.getSpeciesByPercent().size() > 0) {
				species = stand.getSpeciesByPercent().get(0);
			}
		}

		return species;
	}

	public Double determineLeadingSiteSpeciesHeight(int targetAge) {
		if (siteSpecies == null || siteSpecies.size() == 0) {
			throw new IllegalStateException(
					"Layer.determineLeadingSiteSpeciesHeight: siteSpecies == null || siteSpecies.size() == 0"
			);
		}

		var leadingSiteSpecies = siteSpecies.get(0);

		if (!leadingSiteSpecies.getHasSiteInfo()) {
			throw new IllegalStateException(
					"Layer.determineLeadingSiteSpeciesHeight: ! leadingSiteSpecies.getHasSiteInfo()"
			);
		}

		return leadingSiteSpecies.getStand().getSpeciesByPercent().get(0).getDominantHeight();
	}

	/**
	 * Return true iff this layer contains at least one sp64 with a height, and the leading sp64 of all sp0s is at least
	 * the given height.
	 *
	 * @param minVeteranLayerHeight the height lower bound
	 * @return as described
	 */
	public Boolean doesHeightExceed(Double minHeight) {

		boolean heightRequirementMet = true;
		boolean haveSeenSp64WithHeight = false;

		for (Integer sp64Index = 0; sp64Index < sp64s.size(); sp64Index++) {

			var sp64 = findNthSpeciesByCriteria(sp64Index, SpeciesSelectionCriteria.AS_SUPPLIED);

			if (sp64.getDominantHeight() != null) {
				haveSeenSp64WithHeight = true;
				if (sp64.getDominantHeight() < minHeight) {
					heightRequirementMet = false;
					break;
				}
			}
		}

		return haveSeenSp64WithHeight && heightRequirementMet;
	}

	/**
	 * Return the <code>n</code>th species (Sp64) of the layer from a list sorted by <code>criteria</code>.
	 *
	 * @param n        the zero-based index
	 * @param criteria the sorting criteria
	 * @return as described
	 */
	public Species findNthSpeciesByCriteria(Integer n, SpeciesSelectionCriteria criteria) {

		if (0 > n || n >= this.sp64s.size()) {
			throw new IllegalArgumentException(
					MessageFormat.format(
							"The parameter \"n\" (value {0}) must be between 0 and {1}, inclusive", n, this.sp64s.size()
					)
			);
		}

		switch (criteria) {
		case AS_SUPPLIED:
			return this.getSp64sAsSupplied().get(n);
		case BY_NAME:
			return this.getSp64sByName().get(n);
		case BY_PERCENT:
			return this.getSp64sByPercent().get(n);
		default:
			throw new IllegalArgumentException(
					MessageFormat.format("The parameter \"criteria\" (value {0}) is not a recognized value", criteria)
			);
		}
	}

	/**
	 * Return the assigned projection type for this layer; if one has not yet been assigned, determine it based on the
	 * containing polygon's characteristics.
	 *
	 * @param polygon the layer's container
	 * @return as described
	 */
	public ProjectionTypeCode determineProjectionType(Polygon polygon) {

		var projectionType = this.getAssignedProjectionType();

		if (projectionType == ProjectionTypeCode.UNKNOWN) {
			if (this == polygon.getDeadLayer()) {
				projectionType = ProjectionTypeCode.DEAD;
			} else if (this == polygon.getPrimaryLayer() || this == polygon.getTargetedPrimaryLayer()) {
				projectionType = ProjectionTypeCode.PRIMARY;
			} else if (this == polygon.getVeteranLayer() || this == polygon.getTargetedVeteranLayer()) {
				projectionType = ProjectionTypeCode.VETERAN;
			} else if (this == polygon.getResidualLayer()) {
				projectionType = ProjectionTypeCode.RESIDUAL;
			} else if (this == polygon.getRegenerationLayer()) {
				projectionType = ProjectionTypeCode.REGENERATION;
			} else {
				projectionType = ProjectionTypeCode.DO_NOT_PROJECT;
			}
		}

		return projectionType;
	}

	/**
	 * <code>lcl_DetermineLayerAgeAtYear</code>
	 * <p>
	 * Determine the layer's age at the given year, which must be non-null and between 1400 and 2500 (inclusive.)
	 *
	 * @param year as described
	 * @return as described
	 * @throws PolygonValidationException if:
	 *                                    <ul>
	 *                                    <li>the leading species has no total age value
	 *                                    <li>the containing polygon's measurement year cannot be calculated
	 *                                    </ul>
	 * @throws IllegalStateException      if:
	 *                                    <ul>
	 *                                    <li>year is null or out of range
	 *                                    <li><code>this</code> has no leading species
	 *                                    </ul>
	 */
	public Double determineLayerAgeAtYear(Integer year) {

		Double layerAge = null;

		if (year == null || year < Vdyp7Constants.MIN_CALENDAR_YEAR || year > Vdyp7Constants.MAX_CALENDAR_YEAR) {
			throw new IllegalArgumentException(
					MessageFormat.format(
							"Invalid year {0}; must be non null and between {1} and {2} (inclusive)", year,
							Vdyp7Constants.MIN_CALENDAR_YEAR, Vdyp7Constants.MAX_CALENDAR_YEAR
					)
			);
		}

		Stand leadingSp0 = determineLeadingSp0(0);
		Double totalAge = null;
		if (leadingSp0 == null) {
			logger.warn("{}: leading Sp0 not found for layer", this);
		} else if (leadingSp0.getSpeciesGroup().getTotalAge() == null) {
			logger.warn("{}: leading Sp0 \"{}\" of layer has no total age", this, leadingSp0.getSpeciesGroup());
		} else {
			totalAge = leadingSp0.getSpeciesGroup().getTotalAge();
		}

		Integer measurementYear = getPolygon().getMeasurementYear();
		if (measurementYear == null) {
			logger.warn("{}: measurement year is not known for polygon {}", this, getPolygon());
		}

		if (totalAge != null && measurementYear != null) {
			layerAge = leadingSp0.getSpeciesGroup().getTotalAge() + year - measurementYear;
			if (layerAge < 0.0) {
				layerAge = 0.0;
			}
		}

		return layerAge;
	}

	public Integer determineYearAtAge(double age) {

		Integer calendarYear = null;
		
		var leadingSiteSp0 = determineLeadingSp0(0);
		if (leadingSiteSp0 != null) {
			
			var measurementAge = Math.round(leadingSiteSp0.getSpeciesGroup().getTotalAge());
			var measurementYear = polygon.getMeasurementYear();
			calendarYear = (int)(measurementYear + Math.round(age) - measurementAge);
		}

		return calendarYear;
	}

	public void determineAgeAtDeath() throws PolygonValidationException {
		ageAtDeath = determineLayerAgeAtYear(yearOfDeath);
	}

	public void setAsDeadLayer(Integer yearOfDeath, Double percentStockKilled) {

		this.vdyp7LayerCode = ProjectionTypeCode.DEAD;
		this.isDeadLayer = true;
		this.percentStockable = percentStockKilled;
		this.yearOfDeath = yearOfDeath;

		logger.debug(
				"{}: marked as a Dead Layer with mortality occurring in {} and affecting {}% of the land", this,
				yearOfDeath, percentStockable
		);
	}

	/**
	 * <code>V7Ext_CompletedPolygonDefinition</code>, layer portion (lines 4300 - 4362).
	 *
	 * Complete the definition of the Layer, assigning the projection type, building the Site Species,
	 *
	 * @throws PolygonValidationException
	 */
	public void doCompleteDefinition() throws PolygonValidationException {

		if (getDoSuppressPerHAYields()) {

			setAssignedProjectionType(ProjectionTypeCode.UNKNOWN);
		}

		if (getAssignedProjectionType() == ProjectionTypeCode.UNKNOWN) {

			var layerProjectionType = determineProjectionType(polygon);

			if (ProjectionTypeCode.ACTUAL_PROJECTION_TYPES_SET.contains(layerProjectionType)) {
				setAssignedProjectionType(layerProjectionType);
			} else if (layerProjectionType.equals(ProjectionTypeCode.UNKNOWN)) {
				// If the layer still does not have a projection type, suppress projection.
				setDoSuppressPerHAYields(true);
			} else if (layerProjectionType.equals(ProjectionTypeCode.DO_NOT_PROJECT)) {
				// If the layer is marked to not be projected, suppress projection.
				setDoSuppressPerHAYields(true);
			} else {
				throw new IllegalStateException(
						MessageFormat.format("Unrecognized ProjectionTypeCode {0}", layerProjectionType)
				);
			}
		}
	}

	/**
	 * Build the Site Species list from the Layer's stands. This logic is from <code>lcl_RebuildSiteSpeciesArray</code>,
	 * excluding the sorting logic (lines 7750 - 7778).
	 * <p>
	 * There are two steps to building the site species array:
	 * <ol>
	 * <li>Reset the array to be empty.
	 * <li>Load the Site Species array in decreasing order of SP0 percent. We must combine any C and Y SP0s. We must
	 * also combine any PA and PL SP0s
	 * <li>Sort the Site Species Array using the combined SP0 percent. The tie breaker sorts by increasing alphabetical
	 * SP0 Name.
	 * </ol>
	 * When combining SP0s (C/Y and PA/PL), percents are summed together and the secondary SP0 loses its identity to the
	 * more significant SP0.
	 * <p>
	 * The original code contains this comment: "when combining SP0s and the primary SP0 does not have site index
	 * information but the secondary SP0 does, the primary SP0 loses its identity to the secondary SP0", but this is not
	 * implemented in the original code.
	 *
	 * @param growthModelCode
	 */
	void doBuildSiteSpecies() {

		unsortedSiteSpecies = new ArrayList<SiteSpecies>();

		SiteSpecies pSiteSpecies = null;
		SiteSpecies cSiteSpecies = null;

		for (Stand stand : sp0s) {

			var standSp0 = stand.getSpeciesGroup();

			var newSiteSpeciesBuilder = new SiteSpecies.Builder().stand(stand)
					.totalSpeciesPercent(standSp0.getSpeciesPercent());

			if ("C".equals(standSp0.getSpeciesCode()) || "Y".equals(standSp0.getSpeciesCode())) {

				if (cSiteSpecies == null) {

					cSiteSpecies = newSiteSpeciesBuilder.hasBeenCombined(false).build();
					unsortedSiteSpecies.add(cSiteSpecies);

				} else {
					var currentCedarSiteSpeciesGroup = cSiteSpecies.getStand().getSpeciesGroup();
					var oldPercentageMinusNew = currentCedarSiteSpeciesGroup.getSpeciesPercent()
							- standSp0.getSpeciesPercent();
					var oldNameComparedToNew = currentCedarSiteSpeciesGroup.getSpeciesCode()
							.compareTo(standSp0.getSpeciesCode());

					if (oldPercentageMinusNew > 0 || oldPercentageMinusNew == 0 && oldNameComparedToNew < 0) {
						// The new cedar SiteSpecies will be merged into the existing one since it has
						// a lower percentage or the same percentage but a later name.
						cSiteSpecies.incrementTotalSpeciesPercent(standSp0.getSpeciesPercent());
					} else {
						unsortedSiteSpecies.remove(cSiteSpecies);
						var newSiteSpecies = newSiteSpeciesBuilder.hasBeenCombined(true).build();
						newSiteSpecies.incrementTotalSpeciesPercent(cSiteSpecies.getTotalSpeciesPercent());
						unsortedSiteSpecies.add(cSiteSpecies = newSiteSpecies);
					}
				}
			} else if ("PA".equals(standSp0.getSpeciesCode()) || "PL".equals(standSp0.getSpeciesCode())) {

				if (pSiteSpecies == null) {

					pSiteSpecies = newSiteSpeciesBuilder.hasBeenCombined(false).build();
					unsortedSiteSpecies.add(pSiteSpecies);

				} else {
					var currentPineSiteSpeciesGroup = pSiteSpecies.getStand().getSpeciesGroup();
					var oldPercentageMinusNew = currentPineSiteSpeciesGroup.getSpeciesPercent()
							- standSp0.getSpeciesPercent();
					var oldNameComparedToNew = currentPineSiteSpeciesGroup.getSpeciesCode()
							.compareTo(standSp0.getSpeciesCode());

					if (oldPercentageMinusNew > 0 || oldPercentageMinusNew == 0 && oldNameComparedToNew < 0) {
						// The new pine SiteSpecies will be merged into the existing one since it has
						// a lower percentage or the same percentage but a later name.
						pSiteSpecies.incrementTotalSpeciesPercent(standSp0.getSpeciesPercent());
					} else {
						unsortedSiteSpecies.remove(pSiteSpecies);
						var newSiteSpecies = newSiteSpeciesBuilder.hasBeenCombined(true).build();
						newSiteSpecies.incrementTotalSpeciesPercent(pSiteSpecies.getTotalSpeciesPercent());
						unsortedSiteSpecies.add(pSiteSpecies = newSiteSpecies);
					}
				}
			} else {
				unsortedSiteSpecies.add(newSiteSpeciesBuilder.hasBeenCombined(false).build());
			}
		}
		
		// not yet sorted...
		siteSpecies = null;
	}
	
	void doSortSiteSpecies(GrowthModelCode growthModelCode) {
		
		siteSpecies = unsortedSiteSpecies;

		if (growthModelCode == GrowthModelCode.FIP) {
			// sorting is not necessary - the above implementation orders the SiteSpecies in the
			// correct way for FIP.
		} else {
			siteSpecies.sort(SiteSpecies::compareTo_VRI);
		}
	}

	/**
	 * <code>V7Int_FillInOneSiteSpeciesSIInfo</code>
	 * <p>
	 * Fills in the Site Species SI Info for this layer.
	 * <p>
	 * This routine implements the algorithm described in IPSCB205 for 'Site Species Fill In'. Boiled down into
	 * pseudo-code, the following rules are implemented:
	 * <ol>
	 * <li>The supplied layer must have a stand description.
	 * <li>Determine leading site species. If site species already has site information, we are done.
	 * <li>Determine a 'donor' species by selecting the first alphabetical species in the stand description which has
	 * site information.
	 * <li>Copy donor species age to site species age.
	 * <li>Convert SI of donor species to that of site species and copy to Estimated Site Index field.
	 * <li>Compute height for site species based on Age and SI. In our case, we will reset height as it will be
	 * recomputed when all species details are filled in later.
	 * </ol>
	 *
	 * @throws PolygonValidationException
	 */
	void doCompleteSiteSpeciesSiteIndexInfo() throws PolygonValidationException {

		boolean amDone = false;

		if (this.sp64s.size() == 0) {
			amDone = true;
			logger.debug("Layer \"{}\" does not have a stand description. Cannot complete site index info.", this);
		}

		Stand stand = null;
		Species siteSpecies = null;
		Species speciesGroup = null;

		if (!amDone) {
			stand = determineLeadingSp0(0 /* first */);
			siteSpecies = determineLeadingSp64(0 /* first */);

			if (stand != null) {
				logger.debug(
						"{}: located Site SP0 \"{}\" with site info: Age: {}, Ht: {}, SI: {}", this,
						stand.getSpeciesGroup().getSpeciesCode(), stand.getSpeciesGroup().getTotalAge(),
						stand.getSpeciesGroup().getDominantHeight(), stand.getSpeciesGroup().getSiteIndex()
				);
			}
			if (siteSpecies != null) {
				logger.debug(
						"{}: located Site SP64 \"{}\" with site info: Age: {}, Ht: {}, SI: {}", this,
						siteSpecies.getSpeciesCode(), siteSpecies.getTotalAge(), siteSpecies.getDominantHeight(),
						siteSpecies.getSiteIndex()
				);
			}

			if (stand == null || siteSpecies == null) {
				logger.error("{}: leading site species could not be determined; cannot continue", this);

				throw new PolygonValidationException(
						new ValidationMessage(ValidationMessageKind.NO_LEADING_SPECIES, polygon, getLayerId())
				);
			}

			speciesGroup = stand.getSpeciesGroup();

			if (siteSpecies.getTotalAge() != null && siteSpecies.getDominantHeight() != null
					&& siteSpecies.getSiteIndex() != null) {

				logger.debug("{}: leading site species {} already has site information", this, siteSpecies);
				amDone = true;

			} else {

				siteSpecies.calculateUndefinedFieldValues();
				speciesGroup.setSiteCurve(siteSpecies.getSiteCurve());
			}
		}

		Species donorSpecies = null;

		if (!amDone) {

			var sp64sByName = getSp64sByName();

			for (var candidateDonorSpecies : sp64sByName) {

				if (candidateDonorSpecies.getTotalAge() != null && candidateDonorSpecies.getDominantHeight() != null
						&& !siteSpecies.getSpeciesCode().equals(candidateDonorSpecies.getSpeciesCode())) {

					if (candidateDonorSpecies.getSiteIndex() == null) {
						candidateDonorSpecies.calculateUndefinedFieldValues();
					}

					donorSpecies = candidateDonorSpecies;

					if (donorSpecies != null) {
						logger.debug(
								"{}: located Donor SP64 \"{}\" with site info: Age: {}, Ht: {}, SI: {}", this,
								donorSpecies.getSpeciesCode(), donorSpecies.getTotalAge(),
								donorSpecies.getDominantHeight(), donorSpecies.getSiteIndex()
						);
					}
				}
			}

			if (donorSpecies == null) {
				amDone = true;
				logger.debug("{}: unable to find donor species", this);
			}
		}

		if (siteSpecies != null && donorSpecies != null) {

			if (!amDone) {

				// Copy donor species age to the site species.

				siteSpecies.setTotalAge(donorSpecies.getTotalAge());

				logger.debug(
						"{}: set site species {} age from donor species {} to {}", this, siteSpecies.getSpeciesCode(),
						donorSpecies.getSpeciesCode(), donorSpecies.getTotalAge()
				);

				// Attempt to convert and copy (or, failing that, just copy) site index to site species

				var donorSiteIndex = donorSpecies.getSiteIndex() == null ? Vdyp7Constants.EMPTY_DECIMAL
						: donorSpecies.getSiteIndex();
				try {
					double siteIndex = SiteTool.convertSiteIndexBetweenCurves(
							donorSpecies.getSiteCurve(), donorSiteIndex, siteSpecies.getSiteCurve()
					);

					speciesGroup.setSiteIndex(siteIndex);
					siteSpecies.setSiteIndex(siteIndex);

					logger.debug(
							"{}: donor {} site index {} converted to {} and assigned to site species {}", this,
							donorSpecies.getSpeciesCode(), donorSiteIndex, siteSpecies.getSiteIndex(),
							siteSpecies.getSpeciesCode()
					);

				} catch (CommonCalculatorException e) {

					speciesGroup.setSiteIndex(donorSiteIndex);
					siteSpecies.setSiteIndex(donorSiteIndex);

					logger.debug(
							"{}: no conversion of site index from {} to {}. Assigned straight copy of donor site index value {} to site species",
							this, donorSpecies.getSpeciesCode(), siteSpecies.getSpeciesCode(), donorSiteIndex
					);
				}

				// Now reset dominant height and recompute it from the values assigned above.

				siteSpecies.resetDominantHeight();
				siteSpecies.calculateUndefinedFieldValues();

				amDone = true;
			}

			if (amDone && stand != null && siteSpecies != null) {
				speciesGroup.updateAfterSp64Added(siteSpecies);
				speciesGroup.calculateUndefinedFieldValues();
			}
		}
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof Layer that) {
			return compareTo(that) == 0;
		} else {
			return false;
		}
	}

	@Override
	public int hashCode() {
		return polygon.hashCode() * 17 + this.layerId.hashCode();
	}

	@Override
	public int compareTo(Layer that) {
		if (this.polygon.compareTo(that.polygon) == 0) {
			return this.layerId.compareTo(that.layerId);
		} else {
			return 0;
		}
	}

	// toString implementations

	@Override
	public String toString() {
		return polygon.toString() + ":" + this.getLayerId();
	}

	public String toDetailedString() {
		// TODO: elaborate, in the manner of V7Ext_LogLayerDescriptor
		return toString();
	}
}
