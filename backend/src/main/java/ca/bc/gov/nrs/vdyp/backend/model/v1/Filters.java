/*
 * Variable Density Yield Projection
 * API for the Variable Density Yield Projection service
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package ca.bc.gov.nrs.vdyp.backend.model.v1;

import java.util.Objects;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import io.quarkus.runtime.annotations.RegisterForReflection;

/**
 * Filters
 */
@JsonPropertyOrder(
	{ Filters.JSON_PROPERTY_MAINTAINER, Filters.JSON_PROPERTY_MAPSHEET, Filters.JSON_PROPERTY_POLYGON,
			Filters.JSON_PROPERTY_POLYGON_ID }
)
@RegisterForReflection
public class Filters {
	public static final String JSON_PROPERTY_MAINTAINER = "maintainer";
	@JsonProperty(JSON_PROPERTY_MAINTAINER)
	private String maintainer;

	public static final String JSON_PROPERTY_MAPSHEET = "mapsheet";
	@JsonProperty(JSON_PROPERTY_MAPSHEET)
	private String mapsheet;

	public static final String JSON_PROPERTY_POLYGON = "polygon";
	@JsonProperty(JSON_PROPERTY_POLYGON)
	private String polygon;

	public static final String JSON_PROPERTY_POLYGON_ID = "polygonId";
	@JsonProperty(JSON_PROPERTY_POLYGON_ID)
	private String polygonId;

	public Filters copy() {
		return new Filters().maintainer(maintainer).mapsheet(mapsheet).polygon(polygon).polygonId(polygonId);
	}

	/**
	 * only those polygons with the specified maintainer will be considered for inclusion in the output
	 *
	 * @return maintainer
	 **/
	@JsonProperty(value = "maintainer")
	public String getMaintainer() {
		return maintainer;
	}

	public Filters maintainer(String maintainer) {
		setMaintainer(maintainer);
		return this;
	}

	public void setMaintainer(String maintainer) {
		this.maintainer = maintainer;
	}

	/**
	 * only those polygons with the specified mapsheet will be considered for inclusion in the output
	 *
	 * @return mapsheet
	 **/
	@JsonProperty(value = "mapsheet")
	public String getMapsheet() {
		return mapsheet;
	}

	public Filters mapsheet(String mapsheet) {
		setMapsheet(mapsheet);
		return this;
	}

	public void setMapsheet(String mapsheet) {
		this.mapsheet = mapsheet;
	}

	/**
	 * only the polygon with the specified polygon number will be considered for inclusion in the output
	 *
	 * @return polygon
	 **/
	@JsonProperty(value = "polygon")
	public String getPolygon() {
		return polygon;
	}

	public Filters polygon(String polygon) {
		setPolygon(polygon);
		return this;
	}

	public void setPolygon(String polygon) {
		this.polygon = polygon;
	}

	/**
	 * only the polygon with the specified polygon id will be considered for inclusion in the output
	 *
	 * @return polygonId
	 **/
	@JsonProperty(value = "polygonId")
	public String getPolygonId() {
		return polygonId;
	}

	public Filters polygonId(String polygonId) {
		setPolygonId(polygonId);
		return this;
	}

	public void setPolygonId(String polygonId) {
		this.polygonId = polygonId;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		Filters filters = (Filters) o;
		return Objects.equals(this.maintainer, filters.maintainer) && Objects.equals(this.mapsheet, filters.mapsheet)
				&& Objects.equals(this.polygon, filters.polygon) && Objects.equals(this.polygonId, filters.polygonId);
	}

	@Override
	public int hashCode() {
		return Objects.hash(maintainer, mapsheet, polygon, polygonId);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class Filters {\n");
		sb.append("    maintainer: ").append(toIndentedString(maintainer)).append("\n");
		sb.append("    mapsheet: ").append(toIndentedString(mapsheet)).append("\n");
		sb.append("    polygon: ").append(toIndentedString(polygon)).append("\n");
		sb.append("    polygonId: ").append(toIndentedString(polygonId)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces (except the first line).
	 */
	private String toIndentedString(Object o) {
		if (o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}
}
